<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>Reference</title><url>/posts/20240508/reference/</url><categories/><tags/><content type="html"><![CDATA[  引用和借用 fn main(){ let s1 = String::from(&#34;hello&#34;); let len = calculate_length(&amp;s1); println!(&#34;The length of &#39;{}&#39; is {}&#34;,s1,len); } fn calculate_length(s: &amp;String) -&gt; usize { s.len } 在这个例子中，参数类型是&amp;String 而不是 String
&amp;表示引用，引用只获得某些值而不获得所有权
我们把引用作为函数参数这个行为叫做借用
那我们可以修改借用的东西吗
fn main(){ let s1 = String::from(&#34;hello&#34;); let len = calculate_length(&amp;s1); println!(&#34;The length of &#39;{}&#39; is {}&#34;,s1,len); } fn calculate_length(s: &amp;String) -&gt; usize { s.push_str(&#34;,world&#34;) s.len } 运行会报错，如下： 所以不可以修改引借用的东西
和变量一样，引用默认不可变
可变引用 fn main(){ let mut s1 = String::from(&#34;hello&#34;); let len = calculate_length(&amp;mut s1); println!(&#34;The length of &#39;{}&#39; is {}&#34;,s1,len); } fn calculate_length(s: &amp;mut String) -&gt; usize { s.push_str(&#34;,world&#34;) s.len } 引用所引用的内容也要是可变的
同时一个变量只能有一个可变引用
error[E0499]:cannot borrow &rsquo;s&rsquo; as mutable more than once at a time 这样做可以防止编译时数据竞争。
以下三种行为会发生数据竞争：
两个或多个指针同时访问同一个数据 至少有一个指针用于写入数据 没有使用任何机制同步对数据的访问 可以通过创建新的作用域，来允许非同时的创建多个可变引用
fn main() { let mut s = String::from(&#34;hello&#34;); { let s1 = &amp;mut s; } let s2 = &amp;mut s; } 但是还有另一个限制：
不可以同时拥有一个不可变引用和可变引用 允许拥有多个不可变引用 fn main() { let mut s = String::from(&#34;hello&#34;); let r1 = &amp;s; let r2 = &amp;s; let s1 = &amp;mut s; println!(&#34;{},{},{}&#34;,r1,r2,s1); } 悬空引用Dangling references 悬空指针（Dangling Pointer）：一个指针引用了内存中的某个地址，而这块内存可能已经被释放并分配给其他人使用了。
但是在rust中，编译器可以永远保证都不是悬空引用
如果你使用了某些数据，编译器将保证在离开作用域之前数据不会离开作用域
fn main() { let r = dangle(); } fn dangle() -&gt; &amp;String { let s = String::from(&#34;hello&#34;); &amp;s }   ]]></content></entry><entry><title>所有权与函数</title><url>/posts/20240501/rust3/</url><categories/><tags/><content type="html"><![CDATA[  所有权与函数 在语义上，将值传递给函数和把值赋值给变量是类似的，要么发生移动，要么发生复制 let s = String::from(&#34;hello,world&#34;); take_ownership(s); let x = 5; makes_copy(x); println!(&#34;X:{}&#34;,x); fn take_ownership(some_string:String){ println!(&#34;{}&#34;,some_string); } fn make_copy(some_number: i32){ println!(&#34;{}&#34;,some_number); } s的值被移动到函数内，作用域移动到函数，而x由于实现了copy_trait，x仍然有效
返回值与作用域 函数在返回值的过程中也会发生同样的所有权转移 fn main() { let s1 = gives_ownership(); let s2 = String::from(&#34;hello&#34;); let s3 = takes_and_gives_back(s2); } fn gives_ownership() -&gt; String { let some_string = String::from(&#34;hello&#34;); somestring } fn takes_and_gives_back(a_string: String) -&gt; String { a_string } 细细品味所有权的移动！
如何让函数使用某个值但不获得其所有权？ fn main() { let s1 = String::from(&#34;hello&#34;); let (s2, len) = calculate_length(s1); println!(&#34;The length of &#39;{}&#39; is {}&#34;,s2,len); } fn calculate_length(s: String) -&gt; (String, usize){ let length = s.len(); (s, length) } 这样的方法太笨了，像C++一样，为了方便，rust也引入了“引用（reference）”
（待更新）
  ]]></content></entry><entry><title>所有权规则，内存与分配</title><url>/posts/20240426/rust2/</url><categories/><tags/><content type="html"><![CDATA[  String类型 String比其他标量数据类型都复杂。 字符串字面值：程序里手写的字符串的值，他们是不可变的。 string在heap上分配，能够储存编译时未知数量的文本 创建string类型的值 可以通过from函数从字符串字面值创建string类型 example： let s = String::from(&ldquo;hello); &ldquo;::&ldquo;表示from是String类型下的函数 这类字符串可以修改 fn main() { let mut s = String::from(&#34;hello&#34;); s.push_str(&#34;, world&#34;); println!(&#34;{}&#34;,s) } 运行结果：hello，world
为什么String类型的值可以修改，而字符串字面量不可以修改？ 内存和分配 字符串字面值，在编译是就已知它的内容，其文本内容直接被硬编码到可执行文件里 rust采用了不同的方式，对于某个值来说，当拥有它的变量走出作用域范围时，内存会立即自动交还给操作系统，自动调用drop函数 变量与数据交互的方式：移动（Move） 多个变量可以与同一个数据使用一种独特的方式交互 let x = 5; let y = x; 由于整数是已知的固定大小的简单的值，这两个5被压到了Stack中 String版本 let s1 = String::from(&#34;hello&#34;); let s2 = s1; string的交互方式 如果创s2之后再使用s1会怎样呢 let s1 = String::from(&#34;hello&#34;); let s2 = s1; println!(&#34;{}&#34;,s1); 运行结果： 交互方式：克隆 let s1 = String::from(&#34;hello&#34;); let s2 = s1.clone(); println!(&#34;{}&#34;,s1); clone属于深拷贝
stack上的数据：复制 fn main() { let x = 5; let y = x; println!(&#34;{},{}&#34;,x,y); } copy trait,可以用于像整数一样完全存放在stack上的类型 如果一个类型实现了copy这个trait，那么旧的变量在赋值后依然可用 如果一个类型或者该类型的一部分实现了drop trait，那么rust不再允许它实现Copy trait了 一些拥有copy trait的类型 任何简单的标量组合类型都可以是copy的 任何需要分配内存或某种资源的都不是Copy的 一些拥有Copt trait的类型：
所有的整数类型，例如u32
bool
char
所有的浮点类型，例如f64
Tuple（元组），如果其所有字段都是Copy的
  ]]></content></entry><entry><title>大国农村的前世今生</title><url>/posts/20240416/xaingcun/</url><categories/><tags/><content type="html"> 你心中的农村是什么样的呢 那你又是否愿意俯身农村，去农村发展吗？ 为什么呢
这可能是某些从小生活在农村里的人印象的农村的样子。
”面朝黄土背朝天，扛着锄头吸着烟“ 当然这只是我儿时印象中农村的样子，现在已大有不同
没错，就像图片所展示的这样，现在想起来我的家乡，我首先会想起还不错的楼房，金黄的落日和轻轻略过的风，慢悠悠的生活节奏和朴实的人。
相信老一辈人更能见证我国农村的发展，我们小组成员做了一次采访 （两位长辈比较腼腆没有露面） 采访のvideo 我国的乡村振兴计划 你了解乡村振兴吗？ 乡村振兴计划是什么？，哪年提出来的？又有什么政策文件出台呢？ 乡村振兴战略的主要内容包括以下几个方面：
1.产业发展：促进农村产业结构的调整与升级，发展现代农业，加强农产品加工业，拓展农村电商、乡村旅游等新兴产业，提高农民收入。
2.基础设施建设：改善农村基础设施条件，包括道路、水利、电力、通讯等，提高农村居民的生活质量。
3.生态保护：加强农村生态环境保护和治理，推进绿色生产，改善农村人居环境，建设美丽宜居的乡村。
4.文化传承：弘扬农村优秀传统文化，发展乡村文化产业，提升农村文化软实力。
5.乡村治理：加强农村基层党组织建设，完善乡村治理体系，提高乡村治理能力和水平。
6.扶贫攻坚：继续推进精准扶贫工作，提高农村贫困地区的基础设施和公共服务水平，助力贫困人口脱贫致富。
7.人才培养：鼓励各类人才投身乡村振兴，提高农村教育水平，培养新型职业农民，为乡村振兴提供人才支持。
然而，乡村振兴战略的实施需要各级政府、企事业单位和社会各界共同努力，从而实现农村经济、社会、文化和生态的全面振兴。
农村发展面临的挑战 影响农村发展的因素有很多
其中，人口流无疑是最严重的
有多严重？请看视频： 城市化带来的人口流动 备用链接 谈谈我的家乡农村&amp;amp;ndash;张家口 张家口市位于中国河北省西北部，
拥有丰富的农业和农村资源。
近年来，随着中国经济的快速发展，
张家口市的农业和农村也发生了巨大的变化。
为了提高农业生产效率和农民收入，
张家口市积极推进农业现代化。
这包括推广机械化、智能化的农业设备，
实施科学种植和养殖技术，
以及加强农业基础设施建设。
这些措施有助于提高农业生产效率，
降低生产成本，提高农产品质量。
机遇不是从天而降的 是什么使得张家口得以如此发展呢？
当然是国家政策的扶持：
中国 …</content></entry><entry><title>First try of RUST</title><url>/posts/20240412/rust_day1/</url><categories/><tags/><content type="html"><![CDATA[  First try of rust It&rsquo;s security is really excellent!!!!!
use std::io;//prelude use rand::Rng;//trait use std::cmp::Ordering; fn main() { let secret_number = rand::thread_rng().gen_range(1, 101);//i32,u32,i64 loop{ println!(&#34;guess a number&#34;); //let foo = 1; //let bar = foo; //foo = 2; It&#39;s immutable in common sense let mut guess = String::new();//UTF-8 //:: means new is a union function //key word &#39;mut&#39; means that the &#39;guess&#39; is mutable io::stdin().read_line(&amp;mut guess).expect(&#34;can&#39;t readline&#34;); //The type of the return value of function &#34;stdin&#34; is Stdin //The type of the return value of method &#34;read_line&#34; is io::Result&lt;usize&gt;(enums) //io::Result OK,Err //shadow let guess: u32 = match guess.trim().parse(){ Ok(num) =&gt; num, Err(_) =&gt; continue };//Usually we use match to deal with problem //u32:unsigned match guess.cmp(&amp;secret_number){//seems to be switch Ordering::Less =&gt; println!(&#34;It is too small!&#34;),//3 arms Ordering::Equal =&gt; { println!(&#34;Wiiiiiiiiiiiiiiiiiiiiiiin!&#34;); break;// scape from loop }, Ordering::Greater =&gt; println!(&#34;It is too big&#34;),//larger than } println!(&#34;your answer is {}&#34;, guess); //{} is a placeholder that is replaced with a variable value when out put. } }   ]]></content></entry><entry><title>前端第二天</title><url>/posts/20240227/second_day_for_front_end/</url><categories/><tags/><content type="html"><![CDATA[  设置HTML语言 &lt;!DOCTYPE html&gt; &lt;html lang=&#34;en&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;title&gt;设置HTML语言&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;marquee&gt;I love you&lt;/marquee&gt; &lt;/body&gt; &lt;/html&gt; lang属性 作用：
1、让浏览器显示对应的翻译提示
2、有利于搜索引擎优化。
编写规则： 第一种写法：（语言-国家、地区），例如： zh-CN ===&gt; 中文-中国大陆（简体中文） 第二种写法：（语言-具体种类）
HTML标题和段落标签 标题标签：h1 - h6
注意，h1在整个body里最重要，最好只写一个
h1到h3较为重要
标题标签之间不得嵌套
&lt;!-- 标题标签 --&gt; &lt;!-- h1最重要，无论几个标题，h1最好只写一个 --&gt; &lt;h1&gt; 我是一级标题 &lt;/h1&gt; &lt;p&gt;我是一个段落&lt;/p&gt; &lt;h2&gt;我是二级标题&lt;/h2&gt; &lt;h3&gt;我是三级标题&lt;/h3&gt; &lt;!-- h1~~~h3较为重要 --&gt; &lt;h4&gt;我是四级标题&lt;/h4&gt; &lt;h5&gt;我是五级标题&lt;/h5&gt; &lt;h6&gt;我是六级标题&lt;/h6&gt; 段落标签：p标签
注意p标签不能嵌套标题标签，段落标签和div
&lt;div&gt; &lt;p&gt;我是一个段落&lt;/p&gt; &lt;p&gt;我是又一个段落&lt;/p&gt; &lt;p&gt;我是另一个段落&lt;/p&gt; &lt;/div&gt; &lt;div&gt;无处安放的文字&lt;/div&gt; &lt;!-- 段落p标签 --&gt; &lt;p&gt;我是一个段落&lt;/p&gt; &lt;p&gt;我是一个段落&lt;/p&gt; div标签：可以起到整理代码的作用
语义化标签 语义化：标签默认的效果不重要，语义最重要 语义化的优点 1：代码可读性高，清晰
2：有利于SEO （搜索引擎优化）
3：方便设备解析
  ]]></content></entry><entry><title>前端第一天</title><url>/posts/20240226/day1_for_html/</url><categories/><tags/><content type="html"><![CDATA[  What is HTML It's full name is&quot;HyperText Markup Language&quot;(超文本标记语言) HyperText:hyperlink. markup:It needs variable mark symbols to make it become a hypertext. Language:every symbol,using rule make it a mark language. First experience of HTML ```html &lt;!DOCTYPE html&gt; First experience of html 开始学习前端 ``` # 标签 开始学习前端 起始标签（左） 标签体 结束标签（右） 标签内为标签名，不区分大小写，但规范全小写 有的成对出现，有的单独出现（单标签：例如input） 标签可以嵌套: ```html 开始学习前端 ``` # 标签属性 ```html 开始学习前端 ``` marquee的loop属性，设定循环次数。bgcolor属性设定了背景颜色。 input的type属性使得输入内容为密码，输入时加密 &lt;标签名 属性名=&quot;属性值&quot; 属性名=“属性值”&gt;（起始标签 或 单标签） 个别属性没有属性名，只有值：例如disabled（禁用某些标签） 一个标签可以写多个属性，但不能重复 head和body里面是什么呢？ head： ```html &lt;head&gt; &lt;title&gt;标题&lt;/title&gt; &lt;/head&gt; ``` body：展示在网页上的内容 网页的基本结构 &lt;!DOCTYPE html&gt; &lt;html lang=&#34;en&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;title&gt;...&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt; &lt;/html&gt;   ]]></content></entry><entry><title>学习flask的第五天</title><url>/posts/20240203/flask5/</url><categories/><tags/><content type="html"> flask很好，但我们不合适</content></entry><entry><title>学习flask的第四天</title><url>/posts/20240120/flask4/</url><categories/><tags/><content type="html"><![CDATA[  jinja jinja的基本语法结构 1.块语句： 带有jinja语法关键字的各种标准性语句
jinja变量赋值： {% set links=[ {&#39;lable&#39;:&#39;Home&#39;, &#39;herf&#39;:url_for(&#39;.index&#39;)}, {&#39;lable&#39;:&#39;Home&#39;, &#39;herf&#39;:url_for(&#39;.about&#39;)}, {&#39;lable&#39;:&#39;Home&#39;, &#39;herf&#39;:url_for(&#39;.services&#39;)}, {&#39;lable&#39;:&#39;Home&#39;, &#39;herf&#39;:url_for(&#39;.projects&#39;)} ] %} 使变量失效： {% with %} {% set links=[ {&#39;lable&#39;:&#39;Home&#39;, &#39;herf&#39;:url_for(&#39;.index&#39;)}, {&#39;lable&#39;:&#39;Home&#39;, &#39;herf&#39;:url_for(&#39;.about&#39;)}, {&#39;lable&#39;:&#39;Home&#39;, &#39;herf&#39;:url_for(&#39;.services&#39;)}, {&#39;lable&#39;:&#39;Home&#39;, &#39;herf&#39;:url_for(&#39;.projects&#39;)}, ] %} {% endwith %} 循环语句： &lt;nav&gt; {% for link in links %} &lt;a href=&#34;{{ link.href }}&#34;&gt;{{ link.lable }}&lt;/a&gt; {% endfor %} &lt;/nav&gt; #### 测试函数与自定义测试函数 &lt;nav&gt; {% for link in links %} {% if not loop.first %} | {% endif %} {% if link is current_link %} &lt;a href=&#34;{{ link.href }}&#34;&gt;{{ link.lable }}&lt;/a&gt; {% endif %} {% endfor %} &lt;/nav&gt; @app.template_test(&#39;current_link&#39;) def current_link(link): return link[&#39;href&#39;] == request.path 2.表达式： 例如将变量打印到页面上的“{{}}”语句
3.单行语句 块语句的一种简化形式
all code until today # coding: utf-8 from flask import Flask, render_template,request,redirect,url_for,make_response,abort from werkzeug.routing import BaseConverter from werkzeug.utils import secure_filename from os import path from functools import reduce class RegexConverter(BaseConverter): def __init__(self,url_map,*items): super(RegexConverter,self).__init__(url_map) self.regex=items[0] app = Flask(__name__) app.url_map.converters[&#39;regex&#39;] = RegexConverter @app.route(&#34;/&#34;) def index(): response = make_response(render_template(&#39;index.html&#39;, title=&#39;&lt;h1&gt;hello user&lt;/h1&gt;&#39;, body = &#34;## header&#34; )) response.set_cookie(&#39;user_name&#39;,&#39;&#39;) return response @app.route(&#34;/services&#34;) def services(): return &#39;Services&#39; @app.route(&#34;/About&#34;) def About(): return &#39;About&#39; # 路由转换器：int， float， path路径 @app.route(&#39;/user/&lt;int:user_id&gt;&#39;) def user(user_id): return &#39;User %d&#39; % user_id # 在解释http请求时实际上是指向projects这个虚目录下的一个文件夹 # 通常是index，真正地址(/project/index.html) # 对于上面的about会被作为文件名解释，加一个/会404 @app.route(&#39;/projects/&#39;) @app.route(&#39;/ourroute/&#39;) def projects(): return &#39;the project page&#39; # 可以提供多个url，只需加上一个新的route定义 # 在匹配url规则时是从上往下的，匹配到对应规则就进入函数 # 只能是a-z之间的三个字母 @app.route(&#39;/user/&lt;regex(&#34;[a-z]{3}&#34;):user_ifm&gt;&#39;) def regex(user_ifm): return &#39;User %s&#39; % user_ifm @app.route(&#39;/login&#39;,methods=[&#39;GET&#39;,&#39;POST&#39;]) def login(): if request.method==&#39;POST&#39;: username=request.form[&#39;user_name&#39;] passward=request.form[&#39;passward&#39;] print(username) print(passward) else: username=request.args[&#39;user_name&#39;] print(username) return render_template(&#39;login.html&#39;,method=request.method) @app.route(&#39;/upload&#39;,methods=[&#39;GET&#39;,&#39;POST&#39;]) def upload(): if request.method==&#39;POST&#39;: f = request.files[&#39;file&#39;] basepath = path.abspath(path.dirname(__file__)) upload_path=path.join(basepath,&#39;static/uploads&#39;,secure_filename(f.filename)) f.save(upload_path) return redirect(url_for(&#39;upload&#39;)) return render_template(&#39;upload.html&#39;) @app.errorhandler(404) def page_not_found(error): return render_template(&#39;404.html&#39;), 404 @app.template_filter(&#39;md&#39;) def markdown_to_html(txt): from markdown import markdown return markdown(txt) # 上下文处理器 def read_md(filename): with open(filename,encoding=&#39;utf-8&#39;) as md_file: content = reduce(lambda x, y: x + y, md_file.readlines()) return content @app.context_processor def inject_methods(): return dict(read_md=read_md) @app.template_test(&#39;current_link&#39;) def current_link(link): return link[&#39;href&#39;] == request.path if __name__ == &#34;__main__&#34;: app.run(debug=True)   ]]></content></entry><entry><title>学习flask的第三天</title><url>/posts/20240119/flask3/</url><categories/><tags/><content type="html"><![CDATA[  禁用自动转义 使用jinja的block（块）写法禁用转义
当文件绝对安全时
可以使用|safe过滤器 在jinja中，“|safe”称为过滤器 直接用于禁用自动转义 过滤器本质是在将变量输出到页面前的预操作 一个模板可以使用多个不同的过滤器 例如：{{ title|safe|tojson }} 更多过滤器说明可以看jinja官网 jinja.pocoo.org/docs/dev/tempaltes#builtin-filters
自己做一个Markdown过滤器 需要引入Markdown模块和reduce模块
from functools import reduce 开始定义：
@app.template_filter(&#39;md&#39;) def markdown_to_html(txt): from markdown import markdown return markdown(txt) 写一个上下文处理器 # 上下文处理器 def read_md(filename): with open(filename,encoding=&#39;utf-8&#39;) as md_file: content = reduce(lambda x, y: x + y, md_file.readlines()) return content @app.context_processor def inject_methods(): return dict(read_md=read_md) 尝试调用这个过滤器吧 先创建一个md文件吧 在返回的页面里使用我们的过滤器 运行结果长这样 编码问题 windows能不能放弃你那gbk！！！！ 开头加一个“# coding: utf-8”
# coding: utf-8 在open中加入“encoding=utf-8”
def read_md(filename): with open(filename,encoding=&#39;utf-8&#39;) as md_file: content = reduce(lambda x, y: x + y, md_file.readlines()) return content 截至目前的代码 # coding: utf-8 from flask import Flask, render_template,request,redirect,url_for,make_response,abort from werkzeug.routing import BaseConverter from werkzeug.utils import secure_filename from os import path from functools import reduce class RegexConverter(BaseConverter): def __init__(self,url_map,*items): super(RegexConverter,self).__init__(url_map) self.regex=items[0] app = Flask(__name__) app.url_map.converters[&#39;regex&#39;] = RegexConverter @app.route(&#34;/&#34;) def index(): response = make_response(render_template(&#39;index.html&#39;, title=&#39;&lt;h1&gt;hello user&lt;/h1&gt;&#39;, body = &#34;## header&#34; )) response.set_cookie(&#39;user_name&#39;,&#39;&#39;) return response @app.route(&#34;/service&#34;) def services(): return &#39;Services&#39; @app.route(&#34;/About&#34;) def about(): return &#39;About&#39; # 路由转换器：int， float， path路径 @app.route(&#39;/user/&lt;int:user_id&gt;&#39;) def user(user_id): return &#39;User %d&#39; % user_id # 在解释http请求时实际上是指向projects这个虚目录下的一个文件夹 # 通常是index，真正地址(/project/index.html) # 对于上面的about会被作为文件名解释，加一个/会404 @app.route(&#39;/projects/&#39;) @app.route(&#39;/ourroute/&#39;) def projects(): return &#39;the project page&#39; # 可以提供多个url，只需加上一个新的route定义 # 在匹配url规则时是从上往下的，匹配到对应规则就进入函数 # 只能是a-z之间的三个字母 @app.route(&#39;/user/&lt;regex(&#34;[a-z]{3}&#34;):user_ifm&gt;&#39;) def regex(user_ifm): return &#39;User %s&#39; % user_ifm @app.route(&#39;/login&#39;,methods=[&#39;GET&#39;,&#39;POST&#39;]) def login(): if request.method==&#39;POST&#39;: username=request.form[&#39;user_name&#39;] passward=request.form[&#39;passward&#39;] print(username) print(passward) else: username=request.args[&#39;user_name&#39;] print(username) return render_template(&#39;login.html&#39;,method=request.method) @app.route(&#39;/upload&#39;,methods=[&#39;GET&#39;,&#39;POST&#39;]) def upload(): if request.method==&#39;POST&#39;: f = request.files[&#39;file&#39;] basepath = path.abspath(path.dirname(__file__)) upload_path=path.join(basepath,&#39;static/uploads&#39;,secure_filename(f.filename)) f.save(upload_path) return redirect(url_for(&#39;upload&#39;)) return render_template(&#39;upload.html&#39;) @app.errorhandler(404) def page_not_found(error): return render_template(&#39;404.html&#39;), 404 @app.template_filter(&#39;md&#39;) def markdown_to_html(txt): from markdown import markdown return markdown(txt) # 上下文处理器 def read_md(filename): with open(filename,encoding=&#39;utf-8&#39;) as md_file: content = reduce(lambda x, y: x + y, md_file.readlines()) return content @app.context_processor def inject_methods(): return dict(read_md=read_md) if __name__ == &#34;__main__&#34;: app.run(debug=True)   ]]></content></entry><entry><title>学习flask的第二天</title><url>/posts/20240118/flask2/</url><categories/><tags/><content type="html"><![CDATA[  click 看了半天click用法，还让Mario帮忙，最后还是出错了
from flask import Flask, render_template,request,redirect,url_for,make_response,abort from werkzeug.routing import BaseConverter from werkzeug.utils import secure_filename import click from flask.cli import FlaskGroup from os import path class RegexConverter(BaseConverter): def __init__(self,url_map,*items): super(RegexConverter,self).__init__(url_map) self.regex=items[0] def create_app(): app = Flask(__name__) app.url_map.converters[&#39;regex&#39;] = RegexConverter @app.route(&#34;/&#34;) def index(): response = make_response(render_template(&#39;index.html&#39;, title=&#39;hello user&#39;)) response.set_cookie(&#39;user_name&#39;,&#39;&#39;) return response @app.route(&#34;/service&#34;) def services(): return &#39;Services&#39; @app.route(&#34;/About&#34;) def about(): return &#39;About&#39; # 路由转换器：int， float， path路径 @app.route(&#39;/user/&lt;int:user_id&gt;&#39;) def user(user_id): return &#39;User %d&#39; % user_id # 在解释http请求时实际上是指向projects这个虚目录下的一个文件夹 # 通常是index，真正地址(/project/index.html) # 对于上面的about会被作为文件名解释，加一个/会404 @app.route(&#39;/projects/&#39;) @app.route(&#39;/ourroute/&#39;) def projects(): return &#39;the project page&#39; # 可以提供多个url，只需加上一个新的route定义 # 在匹配url规则时是从上往下的，匹配到对应规则就进入函数 # 只能是a-z之间的三个字母 @app.route(&#39;/user/&lt;regex(&#34;[a-z]{3}&#34;):user_ifm&gt;&#39;) def regex(user_ifm): return &#39;User %s&#39; % user_ifm @app.route(&#39;/login&#39;,methods=[&#39;GET&#39;,&#39;POST&#39;]) def login(): if request.method==&#39;POST&#39;: username=request.form[&#39;user_name&#39;] passward=request.form[&#39;passward&#39;] print(username) print(passward) else: username=request.args[&#39;user_name&#39;] print(username) return render_template(&#39;login.html&#39;,method=request.method) @app.route(&#39;/upload&#39;,methods=[&#39;GET&#39;,&#39;POST&#39;]) def upload(): if request.method==&#39;POST&#39;: f = request.files[&#39;file&#39;] basepath = path.abspath(path.dirname(__file__)) upload_path=path.join(basepath,&#39;static/uploads&#39;,secure_filename(f.filename)) f.save(upload_path) return redirect(url_for(&#39;upload&#39;)) return render_template(&#39;upload.html&#39;) @app.errorhandler(404) def page_not_found(error): return render_template(&#39;404.html&#39;), 404 return app manager = FlaskGroup(create_app=create_app) @click.command(&#34;rundev&#34;) def dev(): from livereload import Server app = create_app() live_server = Server(app.wsgi_app) live_server.watch(&#39;**/*.*&#39;) live_server.serve(open_url=True) @click.command(&#34;hello&#34;) @click.argument(&#39;user_name&#39;) def run(): app = create_app() with app.app_context(): click.echo(app.config) manager.add_command(dev) manager.add_command(run) if __name__ == &#34;__main__&#34;: # app.run(debug=True) manager() 报错长这样： 还是改回去吧。。。
  ]]></content></entry><entry><title>学习Flask的第一天</title><url>/posts/20240116/webday1/</url><categories/><tags/><content type="html"><![CDATA[  1.用到的插件 from flask import Flask, render_template,request from werkzeug.routing import BaseConverter 2.路由转换器 url转换器有三种：int,float,path # 路由转换器：int， float， path路径 @app.route(&#39;/user/&lt;int:user_id&gt;&#39;) def user(user_id): return &#39;User %d&#39; % user_id 运行结果如下图： 3.&quot;/&ldquo;和多个url 首先来看一个简单的about @app.route(&#34;/About&#34;) def about(): return &#39;About&#39; # 在解释http请求时实际上是指向projects这个虚目录下的一个文件夹 # 通常是index，真正地址(/project/index.html) # 对于上面的about会被作为文件名解释，加一个/会404 @app.route(&#39;/projects/&#39;) @app.route(&#39;/ourroute/&#39;) def projects(): return &#39;the project page&#39; # 可以提供多个url，只需加上一个新的route定义 # 在匹配url规则时是从上往下的，匹配到对应规则就进入函数 4.正则表达式 需要创建一个类 class RegexConverter(BaseConverter): def __init__(self,url_map,*items): super(RegexConverter,self).__init__(url_map) self.regex=items[0] app = Flask(__name__) app.url_map.converters[&#39;regex&#39;] = RegexConverter 然后就可以制定url规则了 5.传meythod（涉及HTML） @app.route(&#39;/login&#39;,methods=[&#39;GET&#39;,&#39;POST&#39;]) def login(): return render_template(&#39;login.html&#39;,method=request.method) 运行结果如图： 输入一些内容并提交后 6.至今为止的全代码 from flask import Flask, render_template,request from werkzeug.routing import BaseConverter class RegexConverter(BaseConverter): def __init__(self,url_map,*items): super(RegexConverter,self).__init__(url_map) self.regex=items[0] app = Flask(__name__) app.url_map.converters[&#39;regex&#39;] = RegexConverter @app.route(&#34;/&#34;) def hello(): return render_template(&#39;index.html&#39;, title=&#39;hello world&#39;) @app.route(&#34;/service&#34;) def services(): return &#39;Services&#39; @app.route(&#34;/About&#34;) def about(): return &#39;About&#39; # 路由转换器：int， float， path路径 @app.route(&#39;/user/&lt;int:user_id&gt;&#39;) def user(user_id): return &#39;User %d&#39; % user_id # 在解释http请求时实际上是指向projects这个虚目录下的一个文件夹 # 通常是index，真正地址(/project/index.html) # 对于上面的about会被作为文件名解释，加一个/会404 @app.route(&#39;/projects/&#39;) @app.route(&#39;/ourroute/&#39;) def projects(): return &#39;the project page&#39; # 可以提供多个url，只需加上一个新的route定义 # 在匹配url规则时是从上往下的，匹配到对应规则就进入函数 @app.route(&#39;/user/&lt;regex(&#34;[a-z]{3}&#34;):user_ifm&gt;&#39;) # 只能是a-z之间的三个字母 def regex(user_ifm): return &#39;User %s&#39; % user_ifm @app.route(&#39;/login&#39;,methods=[&#39;GET&#39;,&#39;POST&#39;]) def login(): return render_template(&#39;login.html&#39;,method=request.method) if __name__ == &#34;__main__&#34;: app.run(debug=True)   ]]></content></entry><entry><title>船与海</title><url>/posts/20231229/zs5/</url><categories/><tags/><content type="html"> 张朔 “随波逐流的船，漫无边际的海”</content></entry><entry><title>Welcome</title><url>/posts/20231209/welcome/</url><categories/><tags/><content type="html"> Welcome Welcome to my blog!You can see all my views here!</content></entry></search>