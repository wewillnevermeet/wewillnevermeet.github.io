+++
title = '正则表达式'
date = 2024-09-24T19:02:17+08:00
draft = false
+++

# 正则表达式
很久没写笔记了，写点正则表达式吧
  
![正则](/image/regex.png)

  
图片来自bilibili：geekhour

## 工具


- 一些在线工具
- VSCode也提供了对正则表达式的支持，快捷键ctrl+F

## 构成
正则表达式通常是由两个斜线包裹起来的，  
后面可以跟上一些修饰符。  
例如：  

```regex
/([A-Z])\w+/g
```  

g表示global(全局)  
其他的，例如小写字母i表示忽略大小写  
m表示多行匹配等等  

## .符号
.符号可以表示某部分任意位置的字符串并进行匹配  
例如：  
```regex
/.at/g
```
  
那么所有的"*at"字符串将被匹配  
例如create中的eat将被匹配  

## []字符集合
### 特定字符
如果只想找到at后面的c或者e  
那就可以使用字符集合  
```regex
/at[ce]/g
```
  
这样就可以匹配到所有的atc和ate  
数字也可以使用  
### 范围  
此外，[]中还可以使用范围  
```regex
/at[a-z]/g
```
  
这样就可以匹配at后面跟着小写字母的字符串  
还可以加入更多范围  
```regex
/at[a-zA-Z1-3]/g
```
  
这样，atA,atB...at1,at2,at3也会匹配到  
### ^取反
```regex
/at[^A-Z]/g
```
  
这就表示匹配除了at后面跟着大写字母的at*字符串  
注：^必须在方括号内部才表示取反，在外部表示匹配每一行的开头  
### 预定义字符类
每次使用方括号可能会非常繁琐，  
所以正则表达式提供了一些预定义字符。  
例如\d表示数字，和[0-9]是一样的。  
- \D表示非数字  
- \w表示字母，数字或者下划线  
- \W表示与w相反的范围  
- \s表示空白字符，也就是空格或者Tab  
- \S表示非空白字符  

## 位置和边界匹配
### ^符号
^匹配每行的开头  
例如：/^a/g  
就会找到每段开头为a的字符串，不会匹配到段落内部  
/^a/gm  
加上m表示多行匹配，就可以匹配到每一行的开头的字母a了  

### $符号
$表示匹配每一行的结尾  
比如我们想要找到一片英语文章中的所有以句号结尾的部分，  
就可以在.后面加上$  
/.$/gm  
表示.之后就是这一行的结尾。  
但是除了点号之外其他字符也被匹配到了。  
那么只需要加一个反斜线来转义一下。  
/\.$/gm  
这样就不会匹配其他字符了。  

### \b
\b表示单词边界  
```regex
/\bin/gm
```
这个正则表达式将匹配文本中的开头的in  
\b放在in后面则会匹配末尾的in  
在in前后都加上\b则会匹配单独的单词in  
\B表示相反的含义，即非边界  

## 量词
顾名思义，量词是用来表示重复次数的。  

### +符号
想要找a后面有一个或多个t的字符串，  
就可以在t后面加上一个+。
```regex
    /at+/gm
```
### *符号  
```regex
/at*/gm
```
无论a后面有没有t，有多少个t，都会被匹配到。  
### ?符号  
```regex
/at?/gm
```
只有a或者at会被匹配到。  

### {}指定次数
```regex
/at{3}/gm
```
这样，只有a后面是三个t的字符串会被匹配。  
此外，{}还可以指定范围，使用逗号隔开。  
```regex
/at{3,5}/gm
```
这样，只有a后面是三到五个t的字符串会被匹配。  

## 贪婪匹配
```regex
/at{3,}/gm
```
这里表示t至少重复3次。但是更多次数的也会匹配到。  
这种匹配模式成为贪婪匹配。  
```regex
/at{3,}?/gm
```
加个问号，就会在重复三次后停止匹配。  
这就是非贪婪匹配。  

## 分组和引用

### ()分组
```regex
/(at)*/gm
```
括号内部的字符串将被视为整体处理。  
这个正则表达式将会匹配多次重复的at.  

### []分组
```regex
/[Pp]attern/gm
```
当我们想要匹配一个单词，且无论首字母大小写。  
就可以将大写和小写字母用[]括起来。  

### |或者
对于上一个情况，还可以使用|符号  
```regex
/Pattern|pattern/gm
```
这也可以实现上一个要求。  

### ()和|结合
写两边这个单词未免太麻烦了，不妨分组处理大小写  
```regex
/(P|p)attern/gm
```
它和上面的两条起同样的作用。  

### 多个分组
给定一个场景，我们要提取日期，就可以分组分别提取年月日。
2024-05-01  
2024-05-02  
2024-05-03  
2024-05-04  
2024-05-05  
```regex
/\d{4}-\d{1,2}-\d{1,2}/gm
```
如果我们要改为月日年的格式，就需要创建三个分组。
```regex
/(\d{4})-(\d{1,2})-(\d{1,2})/gm
```
打开替换框 输入：$2-$3-$1  
他们三个分别表示第一个分组，第二个分组第三个分组。  
  
但是期起会有很多格式，比如 ：  
2024-05-01  
2024/05/02  
2024_05_03  
2024.05.04  
20240505

那我们就可以修改正则表达式为：
```regex
/(\d{4})[-/._]?(\d{1,2})[-/._]?(\d{1,2})/gm
```
这样就可以匹配所有日期的时间了。
